## 软件说明    
该软件源码首先引用自url链接: https://blog.csdn.net/sbsbsb666666/article/details/130198264    
其代码采用c++实现了一个简单的ARC算法  
该代码只实现了一个arc算法put操作，相关接口还不完善，代码本身可能也存在不规范性，本代码会在此基础上进行修改和完善    
1.修改注释规范、代码规范  
2.重构代码架构  
3.补齐算法API功能  
    
## 软件功能  
提供一个可用于其他软件项目或工程的动态链接库  
  
## 算法分析  
ARC算法结合了LRU和LFU  
数据结构如下:  
class ARC
  |class LRU
    |hashtable               时间复杂度:O(1)
    |dlinkedlist             删除、插入时间复杂度:O(n)
    |evict_hashtable
    |evict_dlinkedlist       
  |class LFU 
    |hashtable               时间复杂度:O(1)
    |dlinkedlist             删除、插入时间复杂度:O(n)
    |evict_hashtable
    |evict_dlinkedlist 

从最开始的代码风格来看，这个原始的代码应该是一个科班在校生写的，放到了csdn上  
这个数据结构的最核心的问题在于为什么要有淘汰哈希表+ 双向链表?  
原csdn文章里给出的解释是需要通过淘汰hash表判断一个数据到底是符合
最近时间内未使用或使用的数据还是最近时间内频率较高的数据还是不高的数据，如果没有这个结构，则不好判断.  
举例如下：  
```sh  
_ _ _ _ _  | _ _ _ _ _
<---LRU---><---LFU--->   配额都是5个，一共是10个元素

(3) (3) (3)                       --表示次数
 1   2   3 _ _ |  1  2  3 _ _ 
此时两个哈希表里都有1 2 3 这三个元素，如果再插入一个元素4，仅通过
这两个LRU、LFU表是无法判断要插入哪个哈希表，因为不知道这个元素是
陌生元素还是高频元素
此时智能通过哈希表容量，优先插入LRU，
如果此时LRU和LFU都满了，该如何插入？
所以就要有另外一套哈希链表来判断，这就是淘汰哈希表的作用
比如再插入一个元素4，此时先插入LRU，LRU满了需要从尾巴上删除
(1) (3) (3)                       --表示次数
 4   1   2 _ _ |  1  2  3 _ _ 

(0)
 3        | _ _ _ _ _     --> 淘汰哈希表
 LRU淘汰哈希表表示的是这个结构里的元素都是陌生元素,此时找到了3，
 说明3是陌生元素，而不是高频元素，就要对LRU、LFU的哈希链表进行扩容和缩容操作，LRU扩容、LFU缩容  

```  
